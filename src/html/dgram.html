
<!DOCTYPE html>
<html id="maincontent">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="css/api.css">
</head>
<body class="alt apidoc" id="api-section-dgram">
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
    <div id="intro" class="interior">
        <a href="http://nodejs.cn/">
            Node.js 中文网
        </a>
        <div>
            <input placeholder="API 快速搜索" id="search_input">
        </div>
    </div>

    <ul>
        <li><a class="nav-assert" href="assert.html">assert - 断言</a></li>
        <li><a class="nav-buffer" href="buffer.html">Buffer - 缓冲器</a></li>
        <li><a class="nav-child_process" href="child_process.html">child_process - 子进程</a></li>
        <li><a class="nav-cluster" href="cluster.html">cluster - 集群</a></li>
        <li><a class="nav-console" href="console.html">console - 控制台</a></li>
        <li><a class="nav-crypto" href="crypto.html">crypto - 加密</a></li>
        <li><a class="nav-dgram" href="dgram.html">dgram - 数据报</a></li>
        <li><a class="nav-dns" href="dns.html">dns - 域名服务器</a></li>
        <li><a class="nav-errors" href="errors.html">Error - 异常</a></li>
        <li><a class="nav-events" href="events.html">events - 事件</a></li>
        <li><a class="nav-fs" href="fs.html">fs - 文件系统</a></li>
        <li><a class="nav-globals" href="globals.html">global - 全局变量</a></li>
        <li><a class="nav-http" href="http.html">http - HTTP</a></li>
        <li><a class="nav-https" href="https.html">https - HTTPS</a></li>
        <li><a class="nav-modules" href="modules.html">module - 模块</a></li>
        <li><a class="nav-net" href="net.html">net - 网络</a></li>
        <li><a class="nav-os" href="os.html">os - 操作系统</a></li>
        <li><a class="nav-path" href="path.html">path - 路径</a></li>
        <li><a class="nav-process" href="process.html">process - 进程</a></li>
        <li><a class="nav-querystring" href="querystring.html">querystring - 查询字符串</a></li>
        <li><a class="nav-readline" href="readline.html">readline - 逐行读取</a></li>
        <li><a class="nav-repl" href="repl.html">repl - 交互式解释器</a></li>
        <li><a class="nav-stream" href="stream.html">stream - 流</a></li>
        <li><a class="nav-string_decoder" href="string_decoder.html">string_decoder - 字符串解码器</a></li>
        <li><a class="nav-timers" href="timers.html">timer - 定时器</a></li>
        <li><a class="nav-tls" href="tls.html">tls - 安全传输层</a></li>
        <li><a class="nav-tty" href="tty.html">tty - 终端</a></li>
        <li><a class="nav-url" href="url.html">url - 网址</a></li>
        <li><a class="nav-util" href="util.html">util - 实用工具</a></li>
        <li><a class="nav-v8" href="v8.html">v8 - V8引擎</a></li>
        <li><a class="nav-vm" href="vm.html">vm - 虚拟机</a></li>
        <li><a class="nav-zlib" href="zlib.html">zlib - 压缩</a></li>
    </ul>
    <div class="line"></div>
    <ul>
        <li><a class="nav--api-documentation-documentation_stability_index" href="documentation.html">试验的API</a></li>
        <li><a class="nav-async_hooks" href="async_hooks.html">async_hooks</a></li>
        <li><a class="nav-http2" href="http2.html">http2</a></li>
        <li><a class="nav-inspector" href="inspector.html">inspector</a></li>
        <li><a class="nav-n-api" href="n-api.html">napi</a></li>
    </ul>
    <div class="line"></div>
    <ul>
        <li><a class="nav-documentation" href="documentation.html">关于本文档</a></li>
        <li><a class="nav-synopsis" href="synopsis.html">用法与例子</a></li>
        <li><a class="nav-addons" href="addons.html">C++插件</a></li>
        <li><a class="nav-cli" href="cli.html">命令行选项</a></li>
        <li><a class="nav-debugger" href="debugger.html">debugger调试器</a></li>
        <li><a class="nav-intl" href="intl.html">国际化</a></li>
        <li><a class="nav-tracing" href="tracing.html">事件跟踪</a></li>
    </ul>
</div>

        <div id="column1" class='vs interior' data-id="dgram">
            <div id="apicontent">
                <h1 id="udp-datagram-sockets">UDP / Datagram Sockets</h1>
<blockquote>
<p>稳定性: 2 - 稳定的</p>
</blockquote>
<!-- name=dgram -->
<p><code>dgram</code>模块提供了 UDP 数据包 socket 的实现。</p>
<pre><code class="lang-js">const dgram = require(&#39;dgram&#39;);
const server = dgram.createSocket(&#39;udp4&#39;);

server.on(&#39;error&#39;, (err) =&gt; {
  console.log(`服务器异常：\n${err.stack}`);
  server.close();
});

server.on(&#39;message&#39;, (msg, rinfo) =&gt; {
  console.log(`服务器收到：${msg} 来自 ${rinfo.address}:${rinfo.port}`);
});

server.on(&#39;listening&#39;, () =&gt; {
  const address = server.address();
  console.log(`服务器监听 ${address.address}:${address.port}`);
});

server.bind(41234);
// 服务器监听 0.0.0.0:41234
</code></pre>
<h2 id="class-dgram-socket">Class: dgram.Socket</h2>
<!-- YAML
added: v0.1.99
-->
<p><code>dgram.Socket</code>对象是一个封装了数据包函数功能的<a href="events.html"><code>EventEmitter</code></a>。</p>
<p><code>dgram.Socket</code>实例是由<a href="#dgram_dgram_createsocket_options_callback"><code>dgram.createSocket()</code></a>创建的。创建<code>dgram.Socket</code>实例不需要使用<code>new</code>关键字。</p>
<h3 id="event-close-">Event: &#39;close&#39;</h3>
<!-- YAML
added: v0.1.99
-->
<p><code>&#39;close&#39;</code>事件将在使用<a href="#dgram_socket_close_callback"><code>close()</code></a>关闭一个 socket 之后触发。该事件一旦触发，这个 socket 上将不会触发新的<code>&#39;message&#39;</code>事件。</p>
<h3 id="event-error-">Event: &#39;error&#39;</h3>
<!-- YAML
added: v0.1.99
-->
<ul>
<li><code>exception</code> {Error}</li>
</ul>
<p>当有任何错误发生时，<code>&#39;error&#39;</code>事件将被触发。事件发生时，回掉函数仅会接收到一个 Error 参数。</p>
<h3 id="event-listening-">Event: &#39;listening&#39;</h3>
<!-- YAML
added: v0.1.99
-->
<p>当一个 socket 开始监听数据包信息时，<code>&#39;listening&#39;</code>事件将被触发。该事件会在创建 UDP socket 之后被立即触发。</p>
<h3 id="event-message-">Event: &#39;message&#39;</h3>
<!-- YAML
added: v0.1.99
-->
<p>当有新的数据包被 socket 接收时，<code>&#39;message&#39;</code>事件会被触发。<code>msg</code>和<code>rinfo</code>会作为参数传递到该事件的处理函数中。</p>
<ul>
<li><code>msg</code> {Buffer} - 消息</li>
<li><code>rinfo</code> {Object} - 远程地址信息<ul>
<li><code>address</code> {string} 发送方地址 </li>
<li><code>family</code> {string} 地址类型 (<code>&#39;IPv4&#39;</code> or <code>&#39;IPv6&#39;</code>)</li>
<li><code>port</code> {number} The sender port</li>
<li><code>size</code> {number} The message size</li>
</ul>
</li>
</ul>
<h3 id="socket-addmembership-multicastaddress-multicastinterface-">socket.addMembership(multicastAddress[, multicastInterface])</h3>
<!-- YAML
added: v0.6.9
-->
<ul>
<li><code>multicastAddress</code> {string}</li>
<li><code>multicastInterface</code> {string}, 可选的</li>
</ul>
<p>通知内核将<code>multicastAddress</code>和<code>multicastInterface</code>提供的多路传送集合通过<code>IP_ADD_MEMBERSHIP</code>这个 socket 选项结合起来。若<code>multicastInterface</code>参数未指定，操作系统将会选择一个接口并向其添加成员。要为所有可用的接口添加成员，可以在每个接口上调用一次<code>addMembership</code>方法。</p>
<h3 id="socket-address-">socket.address()</h3>
<!-- YAML
added: v0.1.99
-->
<p>返回一个包含 socket 地址信息的对象。对于 UDP socket，该对象将包含<code>address</code>、<code>family</code>和<code>port</code>属性。</p>
<h3 id="socket-bind-port-address-callback-">socket.bind([port][, address][, callback])</h3>
<!-- YAML
added: v0.1.99
-->
<ul>
<li><code>port</code> {number} - 整数，可选的</li>
<li><code>address</code> {string}, 可选的</li>
<li><code>callback</code> {Function} - (没有参数)，可选的。当绑定完成时会被调用。</li>
</ul>
<p>对于 UDP socket，该方法会令<code>dgram.Socket</code>在指定的<code>port</code>和可选的<code>address</code>上监听数据包信息。若<code>port</code>未指定或为 <code>0</code>，操作系统会尝试绑定一个随机的端口。若<code>address</code>未指定，操作系统会尝试在所有地址上监听。绑定完成时会触发一个<code>&#39;listening&#39;</code>事件，并会调用<code>callback</code>方法。</p>
<p>注意，同时监听<code>&#39;listening&#39;</code>事件和在<code>socket.bind()</code>方法中传入<code>callback</code>参数并不会带来坏处，但也不是很有用。</p>
<p>一个被绑定的数据包 socket 会令 Node.js 进程保持运行以接收数据包信息。</p>
<p>若绑定失败，一个<code>&#39;error&#39;</code>事件会被触发。在极少数的情况下（例如尝试绑定一个已关闭的 socket），一个 <a href="errors.html#errors_class_error"><code>Error</code></a> 会被抛出。</p>
<p>一个监听 41234 端口的 UDP 服务器的例子：</p>
<pre><code class="lang-js">const dgram = require(&#39;dgram&#39;);
const server = dgram.createSocket(&#39;udp4&#39;);

server.on(&#39;error&#39;, (err) =&gt; {
  console.log(`服务器异常：\n${err.stack}`);
  server.close();
});

server.on(&#39;message&#39;, (msg, rinfo) =&gt; {
  console.log(`服务器收到：${msg} 来自 ${rinfo.address}:${rinfo.port}`);
});

server.on(&#39;listening&#39;, () =&gt; {
  const address = server.address();
  console.log(`服务器监听 ${address.address}:${address.port}`);
});

server.bind(41234);
// 服务器监听 0.0.0.0:41234
</code></pre>
<h3 id="socket-bind-options-callback-">socket.bind(options[, callback])</h3>
<!-- YAML
added: v0.11.14
-->
<ul>
<li><code>options</code> {Object} - 必要的。包含以下属性：<ul>
<li><code>port</code> {number} - 可选的。</li>
<li><code>address</code> {string} - 可选的。</li>
<li><code>exclusive</code> {boolean} - 可选的。</li>
</ul>
</li>
<li><code>callback</code> {Function} - 可选的。</li>
</ul>
<p>对于 UDP socket，该方法会令<code>dgram.Socket</code>在指定的<code>port</code>和可选的<code>address</code>上监听数据包信息。若<code>port</code>未指定或为 <code>0</code>，操作系统会尝试绑定一个随机的端口。若<code>address</code>未指定，操作系统会尝试在所有地址上监听。绑定完成时会触发一个<code>&#39;listening&#39;</code>事件，并会调用<code>callback</code>方法。</p>
<p>Note that specifying both a <code>&#39;listening&#39;</code> event listener and passing a
<code>callback</code> to the <code>socket.bind()</code> method is not harmful but not very
useful.</p>
<p>在配合<a href="cluster.html"><code>cluster</code></a>模块使用<code>dgram.Socket</code>对象时，<code>options</code>对象可能包含一个附加的<code>exclusive</code>属性。当<code>exclusive</code>被设为<code>false</code>(默认值)时，集群工作单元会使用相同的 socket 句柄来共享连接处理作业。当<code>exclusive</code>被设为<code>true</code>时，该句柄将不会被共享，而尝试共享端口则会造成错误。</p>
<p>A bound datagram socket keeps the Node.js process running to receive
datagram messages.</p>
<p>If binding fails, an <code>&#39;error&#39;</code> event is generated. In rare case (e.g.
attempting to bind with a closed socket), an <a href="errors.html#errors_class_error"><code>Error</code></a> may be thrown.</p>
<p>一个不共享端口的 socket 的例子如下文所示。</p>
<pre><code class="lang-js">socket.bind({
  address: &#39;localhost&#39;,
  port: 8000,
  exclusive: true
});
</code></pre>
<h3 id="socket-close-callback-">socket.close([callback])</h3>
<!-- YAML
added: v0.1.99
-->
<p>关闭该 socket 并停止监听其上的数据。如果提供了一个回调函数，它就相当于为<a href="#dgram_event_close"><code>&#39;close&#39;</code></a>事件添加了一个监听器。</p>
<h3 id="socket-dropmembership-multicastaddress-multicastinterface-">socket.dropMembership(multicastAddress[, multicastInterface])</h3>
<!-- YAML
added: v0.6.9
-->
<ul>
<li><code>multicastAddress</code> {string}</li>
<li><code>multicastInterface</code> {string}, 可选的</li>
</ul>
<p>引导内核通过<code>IP_DROP_MEMBERSHIP</code>这个 socket 选项删除<code>multicastAddress</code>指定的多路传送集合。当 socket 被关闭或进程被终止时，该方法会被内核自动调用，所以大多数的应用都不用自行调用该方法。</p>
<p>若<code>multicastInterface</code>未指定，操作系统会尝试删除所有可用接口上的成员。</p>
<h3 id="socket-ref-">socket.ref()</h3>
<!-- YAML
added: v0.9.1
-->
<p>By default, binding a socket will cause it to block the Node.js process from
exiting as long as the socket is open. The <code>socket.unref()</code> method can be used
to exclude the socket from the reference counting that keeps the Node.js
process active. The <code>socket.ref()</code> method adds the socket back to the reference
counting and restores the default behavior.</p>
<p>Calling <code>socket.ref()</code> multiples times will have no additional effect.</p>
<p>The <code>socket.ref()</code> method returns a reference to the socket so calls can be
chained.</p>
<h3 id="socket-send-msg-offset-length-port-address-callback-">socket.send(msg, [offset, length,] port [, address] [, callback])</h3>
<!-- YAML
added: v0.1.99
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/11985
    description: The `msg` parameter can be an Uint8Array now.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/10473
    description: The `address` parameter is always optional now.
  - version: v6.0.0
    pr-url: https://github.com/nodejs/node/pull/5929
    description: On success, `callback` will now be called with an `error`
                 argument of `null` rather than `0`.
  - version: v5.7.0
    pr-url: https://github.com/nodejs/node/pull/4374
    description: The `msg` parameter can be an array now. Also, the `offset`
                 and `length` parameters are optional now.
-->
<ul>
<li><code>msg</code> {Buffer|Uint8Array|string|array} 要发送的消息</li>
<li><code>offset</code> {number} 整数。可选。指定消息的开头在 buffer 中的偏移量。</li>
<li><code>length</code> {number} 整数。可选。消息的字节数。</li>
<li><code>port</code> {number} 整数。目标端口。</li>
<li><code>address</code> {string} 目标主机名或 IP 地址。可选的。</li>
<li><code>callback</code> {Function} 当消息被发送时会被调用。可选的。</li>
</ul>
<p>在 socket 上发送一个数据包。目标<code>port</code>和<code>address</code>须被指定。</p>
<p><code>msg</code>参数包含了要发送的消息。根据消息的类型可以有不同的做法。如果<code>msg</code>是一个<code>Buffer</code> 或 <code>Uint8Array</code>，则<code>offset</code>和<code>length</code>指定了消息在<code>Buffer</code>中对应的偏移量和字节数。如果<code>msg</code>是一个<code>String</code>，那么它会被自动地按照<code>utf8</code>编码转换为<code>Buffer</code>。对于包含了多字节字符的消息，<code>offset</code>和<code>length</code>会根据对应的<a href="buffer.html#buffer_class_method_buffer_bytelength_string_encoding">byte length</a>进行计算，而不是根据字符的位置。如果<code>msg</code>是一个数组，那么<code>offset</code>和<code>length</code>必须都不能被指定。</p>
<p><code>address</code>参数是一个字符串。若<code>address</code>的值是一个主机名，则 DNS 会被用来解析主机的地址。若<code>address</code>未提供或是非真值，则<code>&#39;127.0.0.1&#39;</code>（用于 <code>udp4</code> socket）或<code>&#39;::1&#39;</code>（用于 <code>udp6</code> socket）会被使用。</p>
<p>若在之前 socket 未通过调用<code>bind</code>方法进行绑定，socket 将会被一个随机的端口号赋值并绑定到“所有接口”的地址上（对于<code>udp4</code> socket 是<code>&#39;0.0.0.0&#39;</code>，对于<code>udp6</code> socket 是<code>&#39;::0&#39;</code>）。</p>
<p>可以指定一个可选的<code>callback</code>方法来汇报 DNS 错误或判断可以安全地重用<code>buf</code>对象的时机。注意，在 Node.js 事件循环中，DNS 查询会对发送造成至少 1 tick 的延迟。</p>
<p>确定数据包被发送的唯一方式就是指定<code>callback</code>。若在<code>callback</code>被指定的情况下有错误发生，该错误会作为<code>callback</code>的第一个参数。若<code>callback</code>未被指定，该错误会以<code>&#39;error&#39;</code>事件的方式投射到<code>socket</code>对象上。</p>
<p>偏移量和长度是可选的，但如其中一个被指定则另一个也必须被指定。另外，他们只在第一个参数是<code>Buffer</code> 或 <code>Uint8Array</code> 的情况下才能被使用。</p>
<p>一个发送 UDP 包到<code>localhost</code>上的某个随机端口的例子：</p>
<pre><code class="lang-js">const dgram = require(&#39;dgram&#39;);
const message = Buffer.from(&#39;Some bytes&#39;);
const client = dgram.createSocket(&#39;udp4&#39;);
client.send(message, 41234, &#39;localhost&#39;, (err) =&gt; {
  client.close();
});
</code></pre>
<p>一个发送包含多个 buffer 的 UDP 包到 <code>127.0.0.1</code> 上的某个随机端口的例子：</p>
<pre><code class="lang-js">const dgram = require(&#39;dgram&#39;);
const buf1 = Buffer.from(&#39;Some &#39;);
const buf2 = Buffer.from(&#39;bytes&#39;);
const client = dgram.createSocket(&#39;udp4&#39;);
client.send([buf1, buf2], 41234, (err) =&gt; {
  client.close();
});
</code></pre>
<p>发送多个 buffer 的速度取决于应用和操作系统。
It is important to run benchmarks to
determine the optimal strategy on a case-by-case basis. Generally speaking,
however, sending multiple buffers is faster.</p>
<p><strong>关于 UDP 包大小的注意事项</strong></p>
<p><code>IPv4/v6</code>数据包的最大尺寸取决于<code>MTU</code>(<em>Maximum Transmission Unit</em>, 最大传输单元)与<code>Payload Length</code>字段大小。</p>
<ul>
<li><p><code>Payload Length</code>字段有<code>16 位</code>宽，指一个超过 64K 的<em>包含</em> IP 头部和数据的负载 (65,507 字节 = 65,535 − 8 字节 UDP 头 − 20 字节 IP 头部)；通常对于环回地址来说是这样，但这个长度的数据包对于大多数的主机和网络来说不切实际。</p>
</li>
<li><p><code>MTU</code>指的是数据链路层为数据包提供的最大大小。对于任意链路，<code>IPv4</code>所托管的<code>MTU</code>最小为<code>68</code>个字节，推荐为<code>576</code>（典型地，作为拨号上网应用的推荐值），无论它们是完整地还是分块地抵达。</p>
<p>对于<code>IPv6</code>，<code>MTU</code>的最小值是<code>1280</code>个字节，然而，受托管的最小的碎片重组缓冲大小为<code>1500</code>个字节。现今大多数的数据链路层技术（如以太网），都有<code>1500</code>的<code>MTU</code>最小值，因而<code>68</code>个字节显得非常小。</p>
</li>
</ul>
<p>要提前知道数据包可能经过的每个链路的 MTU 是不可能的。发送大于接受者<code>MTU</code>大小的数据包将不会起作用，因为数据包会被静默地丢失，而不会通知发送者该包未抵达目的地。</p>
<h3 id="socket-setbroadcast-flag-">socket.setBroadcast(flag)</h3>
<!-- YAML
added: v0.6.9
-->
<ul>
<li><code>flag</code> {boolean}</li>
</ul>
<p>设置或清除 <code>SO_BROADCAST</code> socket 选项。当设置为 <code>true</code>, UDP包可能会被发送到一个本地接口的广播地址</p>
<h3 id="socket-setmulticastloopback-flag-">socket.setMulticastLoopback(flag)</h3>
<!-- YAML
added: v0.3.8
-->
<ul>
<li><code>flag</code> {boolean}</li>
</ul>
<p>设置或清除 <code>IP_MULTICAST_LOOP</code> socket 选项。当设置为 <code>true</code>, 多播数据包也将在本地接口接收。</p>
<h3 id="socket-setmulticastttl-ttl-">socket.setMulticastTTL(ttl)</h3>
<!-- YAML
added: v0.3.8
-->
<ul>
<li><code>ttl</code> {number} Integer</li>
</ul>
<p>Sets the <code>IP_MULTICAST_TTL</code> socket option.  While TTL generally stands for
&quot;Time to Live&quot;, in this context it specifies the number of IP hops that a
packet is allowed to travel through, specifically for multicast traffic.  Each
router or gateway that forwards a packet decrements the TTL. If the TTL is
decremented to 0 by a router, it will not be forwarded.</p>
<p>The argument passed to to <code>socket.setMulticastTTL()</code> is a number of hops
between 0 and 255. The default on most systems is <code>1</code> but can vary.</p>
<h3 id="socket-setttl-ttl-">socket.setTTL(ttl)</h3>
<!-- YAML
added: v0.1.101
-->
<ul>
<li><code>ttl</code> {number} Integer</li>
</ul>
<p>Sets the <code>IP_TTL</code> socket option. While TTL generally stands for &quot;Time to Live&quot;,
in this context it specifies the number of IP hops that a packet is allowed to
travel through.  Each router or gateway that forwards a packet decrements the
TTL.  If the TTL is decremented to 0 by a router, it will not be forwarded.
Changing TTL values is typically done for network probes or when multicasting.</p>
<p>The argument to <code>socket.setTTL()</code> is a number of hops between 1 and 255.
The default on most systems is 64 but can vary.</p>
<h3 id="socket-unref-">socket.unref()</h3>
<!-- YAML
added: v0.9.1
-->
<p>By default, binding a socket will cause it to block the Node.js process from
exiting as long as the socket is open. The <code>socket.unref()</code> method can be used
to exclude the socket from the reference counting that keeps the Node.js
process active, allowing the process to exit even if the socket is still
listening.</p>
<p>Calling <code>socket.unref()</code> multiple times will have no addition effect.</p>
<p>The <code>socket.unref()</code> method returns a reference to the socket so calls can be
chained.</p>
<h3 id="change-to-asynchronous-socket-bind-behavior">Change to asynchronous <code>socket.bind()</code> behavior</h3>
<p>As of Node.js v0.10, <a href="#dgram_socket_bind_options_callback"><code>dgram.Socket#bind()</code></a> changed to an asynchronous
execution model. Legacy code that assumes synchronous behavior, as in the
following example:</p>
<pre><code class="lang-js">const s = dgram.createSocket(&#39;udp4&#39;);
s.bind(1234);
s.addMembership(&#39;224.0.0.114&#39;);
</code></pre>
<p>Must be changed to pass a callback function to the <a href="#dgram_socket_bind_options_callback"><code>dgram.Socket#bind()</code></a>
function:</p>
<pre><code class="lang-js">const s = dgram.createSocket(&#39;udp4&#39;);
s.bind(1234, () =&gt; {
  s.addMembership(&#39;224.0.0.114&#39;);
});
</code></pre>
<h2 id="-dgram-module-functions"><code>dgram</code> module functions</h2>
<h3 id="dgram-createsocket-options-callback-">dgram.createSocket(options[, callback])</h3>
<!-- YAML
added: v0.11.13
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/14560
    description: The `lookup` option is supported.
-->
<ul>
<li><code>options</code> {Object} Available options are:<ul>
<li><code>type</code> {string} The family of socket. Must be either <code>&#39;udp4&#39;</code> or <code>&#39;udp6&#39;</code>.
Required.</li>
<li><code>reuseAddr</code> {boolean} When <code>true</code> <a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> will reuse the
address, even if another process has already bound a socket on it. Optional.
Defaults to <code>false</code>.</li>
<li><code>lookup</code> {Function} Custom lookup function. Defaults to <a href="dns.html#dns_dns_lookup_hostname_options_callback"><code>dns.lookup()</code></a>.
Optional.</li>
</ul>
</li>
<li><code>callback</code> {Function} Attached as a listener for <code>&#39;message&#39;</code> events. Optional.</li>
<li>Returns: {dgram.Socket}</li>
</ul>
<p>Creates a <code>dgram.Socket</code> object. Once the socket is created, calling
<a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> will instruct the socket to begin listening for datagram
messages. When <code>address</code> and <code>port</code> are not passed to  <a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> the
method will bind the socket to the &quot;all interfaces&quot; address on a random port
(it does the right thing for both <code>udp4</code> and <code>udp6</code> sockets). The bound address
and port can be retrieved using <a href="#dgram_socket_address"><code>socket.address().address</code></a> and
<a href="#dgram_socket_address"><code>socket.address().port</code></a>.</p>
<h3 id="dgram-createsocket-type-callback-">dgram.createSocket(type[, callback])</h3>
<!-- YAML
added: v0.1.99
-->
<ul>
<li><code>type</code> {string} - Either &#39;udp4&#39; or &#39;udp6&#39;</li>
<li><code>callback</code> {Function} - Attached as a listener to <code>&#39;message&#39;</code> events.
Optional</li>
<li>Returns: {dgram.Socket}</li>
</ul>
<p>Creates a <code>dgram.Socket</code> object of the specified <code>type</code>. The <code>type</code> argument
can be either <code>udp4</code> or <code>udp6</code>. An optional <code>callback</code> function can be passed
which is added as a listener for <code>&#39;message&#39;</code> events.</p>
<p>Once the socket is created, calling <a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> will instruct the
socket to begin listening for datagram messages. When <code>address</code> and <code>port</code> are
not passed to  <a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> the method will bind the socket to the &quot;all
interfaces&quot; address on a random port (it does the right thing for both <code>udp4</code>
and <code>udp6</code> sockets). The bound address and port can be retrieved using
<a href="#dgram_socket_address"><code>socket.address().address</code></a> and <a href="#dgram_socket_address"><code>socket.address().port</code></a>.</p>

            </div>
        </div>
    </div>    
</body>
<script src="js/all.js"></script>
</html>
